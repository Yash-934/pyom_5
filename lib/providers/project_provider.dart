import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../models/project.dart';

class ProjectProvider extends ChangeNotifier {
  static const _uuid = Uuid();
  
  List<Project> _projects = [];
  Project? _currentProject;
  ProjectFile? _currentFile;
  bool _isLoading = false;
  String? _errorMessage;

  // SharedPreferences Keys
  static const _lastProjectKey = 'last_open_project_id';
  static const _lastFileKey = 'last_open_file_id';

  // Getters
  List<Project> get projects => List.unmodifiable(_projects);
  Project? get currentProject => _currentProject;
  ProjectFile? get currentFile => _currentFile;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  bool get hasOpenProject => _currentProject != null;
  bool get hasOpenFile => _currentFile != null;

  ProjectProvider() {
    _loadProjects();
  }

  Future<void> _loadProjects() async {
    _setLoading(true);
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final projectsFile = File('${appDir.path}/projects.json');
      
      if (await projectsFile.exists()) {
        final content = await projectsFile.readAsString();
        final List<dynamic> data = jsonDecode(content);
        _projects = data.map((p) => Project.fromJson(p)).toList();
      }

      final prefs = await SharedPreferences.getInstance();
      final lastProjectId = prefs.getString(_lastProjectKey);
      final lastFileId = prefs.getString(_lastFileKey);

      if (lastProjectId != null) {
        final exists = _projects.any((p) => p.id == lastProjectId);
        if (exists) {
          await openProject(lastProjectId, restoreFileId: lastFileId);
        }
      }
    } catch (e) {
      _errorMessage = 'Failed to load projects: $e';
    } finally {
      _setLoading(false);
      notifyListeners();
    }
  }

  Future<void> _saveProjects() async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final projectsFile = File('${appDir.path}/projects.json');
      final data = _projects.map((p) => p.toJson()).toList();
      await projectsFile.writeAsString(jsonEncode(data));
    } catch (e) {
      _errorMessage = 'Failed to save projects: $e';
      notifyListeners();
    }
  }

  Future<void> _persistLastOpen() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_currentProject != null) {
        await prefs.setString(_lastProjectKey, _currentProject!.id);
      } else {
        await prefs.remove(_lastProjectKey);
      }
      if (_currentFile != null) {
        await prefs.setString(_lastFileKey, _currentFile!.id);
      } else {
        await prefs.remove(_lastFileKey);
      }
    } catch (_) {}
  }

  // ==================== Project Operations ====================
  
  Future<Project> createProject(String name) async {
    _setLoading(true);
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final projectId = _uuid.v4();
      final projectPath = '${appDir.path}/projects/$projectId';
      
      await Directory(projectPath).create(recursive: true);
      
      final mainFile = ProjectFile(
        id: _uuid.v4(),
        name: 'main.py',
        path: '$projectPath/main.py',
        content: '''#!/usr/bin/env python3
"""
$name - Python Project
Generated by Pyom IDE
"""

def main():
    print("Hello, from Pyom!")

if __name__ == "__main__":
    main()
''',
        modifiedAt: DateTime.now(),
      );
      
      await File(mainFile.path).writeAsString(mainFile.content);
      
      final project = Project(
        id: projectId,
        name: name,
        path: projectPath,
        createdAt: DateTime.now(),
        modifiedAt: DateTime.now(),
        files: [mainFile],
      );
      
      _projects.add(project);
      await _saveProjects();
      
      _currentProject = project;
      _currentFile = mainFile;
      await _persistLastOpen();
      
      return project;
    } catch (e) {
      _errorMessage = 'Failed to create project: $e';
      rethrow;
    } finally {
      _setLoading(false);
      notifyListeners();
    }
  }

  // Import an existing directory as a project (from device file picker)
  Future<Project> createProjectFromPath(String dirPath, String name) async {
    _setLoading(true);
    try {
      final dir = Directory(dirPath);
      final files = <ProjectFile>[];

      await for (final entity in dir.list(recursive: true)) {
        if (entity is File) {
          try {
            final content = await entity.readAsString();
            files.add(ProjectFile(
              id: _uuid.v4(),
              name: entity.path.split('/').last,
              path: entity.path,
              content: content,
              modifiedAt: await entity.lastModified(),
            ));
          } catch (_) {} // Skip binary files
        }
      }

      final project = Project(
        id: _uuid.v4(),
        name: name,
        path: dirPath,
        createdAt: DateTime.now(),
        modifiedAt: DateTime.now(),
        files: files,
      );

      _projects.add(project);
      await _saveProjects();

      _currentProject = project;
      _currentFile = files.isNotEmpty ? files.first : null;
      if (_currentFile != null) {
        _currentProject = project.copyWith(
          files: files.map((f) => f.id == _currentFile!.id ? f.copyWith(isOpen: true) : f).toList(),
        );
      }
      await _persistLastOpen();
      return project;
    } catch (e) {
      _errorMessage = 'Failed to import project: $e';
      rethrow;
    } finally {
      _setLoading(false);
      notifyListeners();
    }
  }

  Future<void> openProject(String projectId, {String? restoreFileId}) async {
    _setLoading(true);
    try {
      final project = _projects.firstWhere((p) => p.id == projectId);
      final dir = Directory(project.path);
      if (!await dir.exists()) throw Exception('Project directory missing');

      final updatedFiles = <ProjectFile>[];
      
      for (final saved in project.files) {
        final diskFile = File(saved.path);
        if (await diskFile.exists()) {
          final content = await diskFile.readAsString();
          updatedFiles.add(saved.copyWith(
            content: content,
            isOpen: false,
            isModified: false,
          ));
        }
      }

      final knownPaths = {for (final f in project.files) f.path};
      await for (final entity in dir.list(recursive: true)) {
        if (entity is File && !knownPaths.contains(entity.path)) {
          try {
            final content = await entity.readAsString();
            updatedFiles.add(ProjectFile(
              id: _uuid.v4(),
              name: entity.path.split('/').last,
              path: entity.path,
              content: content,
              modifiedAt: await entity.lastModified(),
            ));
          } catch (_) {}
        }
      }

      _currentProject = project.copyWith(files: updatedFiles);

      String? fileToOpenId = restoreFileId;
      if (fileToOpenId == null && updatedFiles.isNotEmpty) {
        fileToOpenId = updatedFiles
            .firstWhere((f) => f.isPythonFile, orElse: () => updatedFiles.first)
            .id;
      }
      if (fileToOpenId != null) {
        await openFile(fileToOpenId);
      } else {
        _currentFile = null;
      }
      await _persistLastOpen();

    } catch (e) {
      _errorMessage = 'Failed to open project: $e';
    } finally {
      _setLoading(false);
      notifyListeners();
    }
  }

  Future<void> deleteProject(String projectId) async {
    _setLoading(true);
    try {
      final project = _projects.firstWhere((p) => p.id == projectId);
      
      final dir = Directory(project.path);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
      }
      
      _projects.removeWhere((p) => p.id == projectId);
      
      if (_currentProject?.id == projectId) {
        _currentProject = null;
        _currentFile = null;
        await _persistLastOpen();
      }
      
      await _saveProjects();
    } catch (e) {
      _errorMessage = 'Failed to delete project: $e';
    } finally {
      _setLoading(false);
      notifyListeners();
    }
  }

  Future<void> renameProject(String projectId, String newName) async {
    try {
      final index = _projects.indexWhere((p) => p.id == projectId);
      if (index == -1) return;
      
      _projects[index] = _projects[index].copyWith(name: newName, modifiedAt: DateTime.now());
      
      if (_currentProject?.id == projectId) {
        _currentProject = _projects[index];
      }
      
      await _saveProjects();
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to rename project: $e';
      notifyListeners();
    }
  }

  // ==================== File Operations ====================
  
  Future<void> openFile(String fileId) async {
    if (_currentProject == null) return;
    try {
      final file = _currentProject!.files.firstWhere((f) => f.id == fileId);
      final diskFile = File(file.path);
      final content = await diskFile.exists() ? await diskFile.readAsString() : file.content;

      final fileIndex = _currentProject!.files.indexWhere((f) => f.id == fileId);
      if (fileIndex != -1) {
        final updatedFiles = List<ProjectFile>.from(_currentProject!.files);
        final updatedFile = updatedFiles[fileIndex].copyWith(
          content: content,
          isOpen: true,
          isModified: false,
        );
        updatedFiles[fileIndex] = updatedFile;
        _currentProject = _currentProject!.copyWith(files: updatedFiles);
        _currentFile = updatedFile;
        await _persistLastOpen();
      }
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to open file: $e';
      notifyListeners();
    }
  }

  Future<void> closeFileTab(String fileId) async {
    if (_currentProject == null) return;
    final fileIndex = _currentProject!.files.indexWhere((f) => f.id == fileId);
    if (fileIndex == -1) return;

    final updatedFiles = List<ProjectFile>.from(_currentProject!.files);
    updatedFiles[fileIndex] = updatedFiles[fileIndex].copyWith(isOpen: false);
    _currentProject = _currentProject!.copyWith(files: updatedFiles);

    if (_currentFile?.id == fileId) {
      final nextOpen = updatedFiles.where((f) => f.isOpen).toList();
      _currentFile = nextOpen.isNotEmpty ? nextOpen.last : null;
    }

    await _persistLastOpen();
    notifyListeners();
  }

  Future<void> createFile(String fileName) async {
    if (_currentProject == null) return;
    try {
      final filePath = '${_currentProject!.path}/$fileName';
      final file = File(filePath);
      if (await file.exists()) throw Exception('File already exists');
      
      final content = fileName.endsWith('.py') ? '''#!/usr/bin/env python3\n"""\n$fileName\n"""\n\n''' : '';
      await file.writeAsString(content);
      
      final projectFile = ProjectFile(
        id: _uuid.v4(), name: fileName, path: filePath, content: content, modifiedAt: DateTime.now(),
      );
      
      final updatedFiles = [..._currentProject!.files, projectFile];
      _currentProject = _currentProject!.copyWith(files: updatedFiles, modifiedAt: DateTime.now());
      
      final index = _projects.indexWhere((p) => p.id == _currentProject!.id);
      if (index != -1) _projects[index] = _currentProject!;
      
      await _saveProjects();
      await openFile(projectFile.id);
    } catch (e) {
      _errorMessage = 'Failed to create file: $e';
      notifyListeners();
    }
  }

  Future<void> saveFile(String content, {bool silent = false}) async {
    if (_currentFile == null || _currentProject == null) return;
    try {
      await File(_currentFile!.path).writeAsString(content);
      
      final updatedFile = _currentFile!.copyWith(
        content: content, modifiedAt: DateTime.now(), isModified: false,
      );
      
      final fileIndex = _currentProject!.files.indexWhere((f) => f.id == _currentFile!.id);
      if (fileIndex != -1) {
        final updatedFiles = List<ProjectFile>.from(_currentProject!.files);
        updatedFiles[fileIndex] = updatedFile;
        _currentProject = _currentProject!.copyWith(
          files: updatedFiles, modifiedAt: DateTime.now(),
        );
        _currentFile = updatedFile;
      }
      
      await _saveProjects();
      if (!silent) notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to save file: $e';
      if (!silent) notifyListeners();
    }
  }

  Future<void> deleteFile(String fileId) async {
    if (_currentProject == null) return;
    try {
      final file = _currentProject!.files.firstWhere((f) => f.id == fileId);
      final diskFile = File(file.path);
      if (await diskFile.exists()) await diskFile.delete();
      
      final updatedFiles = _currentProject!.files.where((f) => f.id != fileId).toList();
      _currentProject = _currentProject!.copyWith(files: updatedFiles);
      
      if (_currentFile?.id == fileId) {
        final nextOpen = updatedFiles.where((f) => f.isOpen).toList();
        _currentFile = nextOpen.isNotEmpty ? nextOpen.last : null;
        await _persistLastOpen();
      }
      
      final index = _projects.indexWhere((p) => p.id == _currentProject!.id);
      if (index != -1) _projects[index] = _currentProject!;
      
      await _saveProjects();
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to delete file: $e';
      notifyListeners();
    }
  }

  Future<void> renameFile(String fileId, String newName) async {
    if (_currentProject == null) return;
    try {
      final fileIndex = _currentProject!.files.indexWhere((f) => f.id == fileId);
      if (fileIndex == -1) return;

      final oldFile = _currentProject!.files[fileIndex];
      final newPath = '${oldFile.path.substring(0, oldFile.path.lastIndexOf('/') + 1)}$newName';

      await File(oldFile.path).rename(newPath);

      final updatedFile = oldFile.copyWith(name: newName, path: newPath, modifiedAt: DateTime.now());

      final updatedFiles = List<ProjectFile>.from(_currentProject!.files);
      updatedFiles[fileIndex] = updatedFile;

      _currentProject = _currentProject!.copyWith(files: updatedFiles);

      if (_currentFile?.id == fileId) {
        _currentFile = updatedFile;
      }

      final index = _projects.indexWhere((p) => p.id == _currentProject!.id);
      if (index != -1) _projects[index] = _currentProject!;

      await _saveProjects();
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to rename file: $e';
      notifyListeners();
    }
  }

  void closeProject() {
    _currentProject = null;
    _currentFile = null;
    _persistLastOpen();
    notifyListeners();
  }

  void markFileModified() {
    if (_currentFile == null || _currentFile!.isModified) return;
    _currentFile = _currentFile!.copyWith(isModified: true);
    notifyListeners();
  }

  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  void _setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }
}
